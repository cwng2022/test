<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 手勢互動粒子系統</title>
    
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 引入 MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 鏡頭預覽 (除錯用，設為小視窗) */
        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            z-index: 10;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            transform: scaleX(-1); /* 鏡像顯示，讓使用者操作更直覺 */
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* UI 控制面板 */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 300px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            font-weight: 600;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #aaa;
        }

        /* 按鈕網格 */
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        button.active {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            border-color: transparent;
            font-weight: bold;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* 狀態指示器 */
        #status-indicator {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #ff3333;
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        
        .dot.active {
            background-color: #33ff33;
            box-shadow: 0 0 8px #33ff33;
        }

        /* 載入遮罩 */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- 載入畫面 -->
    <div id="loader">
        <div class="spinner"></div>
        <div>正在啟動攝影機與 AI 模型...</div>
    </div>

    <!-- UI 面板 -->
    <div id="ui-panel">
        <h1>粒子控制器</h1>
        
        <div class="control-group">
            <label>形狀模板</label>
            <div class="shape-grid">
                <button onclick="changeShape('sphere')" class="active" id="btn-sphere">球體 (Sphere)</button>
                <button onclick="changeShape('heart')" id="btn-heart">愛心 (Heart)</button>
                <button onclick="changeShape('saturn')" id="btn-saturn">土星 (Saturn)</button>
                <button onclick="changeShape('dna')" id="btn-dna">DNA 螺旋</button>
                <button onclick="changeShape('cube')" id="btn-cube">立方體 (Cube)</button>
                <button onclick="changeShape('random')" id="btn-random">大爆炸 (Burst)</button>
            </div>
        </div>

        <div class="control-group">
            <label>粒子顏色</label>
            <input type="color" id="colorPicker" value="#00d2ff">
        </div>

        <div id="status-indicator">
            <div class="dot" id="hand-dot"></div>
            <span id="hand-status">等待手勢偵測...</span>
        </div>
        
        <div style="font-size: 0.8rem; color: #666; margin-top: 10px;">
            提示：對著鏡頭<br>
            • 張開手掌 -> 擴大<br>
            • 握拳 -> 縮小
        </div>
    </div>

    <!-- 3D 畫布 -->
    <div id="canvas-container"></div>

    <!-- 攝影機輸入 (隱藏/縮小) -->
    <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
    </div>

    <script>
        // --- 全域變數 ---
        let scene, camera, renderer;
        let particles;
        let geometry;
        const particleCount = 4000;
        
        // 粒子位置數據
        const positions = []; // 目前位置
        const targetPositions = []; // 目標形狀位置
        
        // 互動變數
        let currentShape = 'sphere';
        let handInteractionScale = 1.0; // 手勢控制的縮放比例
        let targetScale = 1.0;          // 目標縮放值 (用於平滑過渡)
        
        // 顏色
        const baseColor = new THREE.Color(0x00d2ff);

        // --- 初始化 Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            // 1. 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            // 2. 攝影機
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. 粒子系統
            geometry = new THREE.BufferGeometry();
            
            // 初始化位置陣列
            const posArray = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(0, 0, 0);
                targetPositions.push(0, 0, 0);
                posArray[i * 3] = 0;
                posArray[i * 3 + 1] = 0;
                posArray[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            // 材質
            const material = new THREE.PointsMaterial({
                color: baseColor,
                size: 0.4,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            // 建立點雲
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 生成初始形狀
            generateShape('sphere');

            // 監聽視窗調整
            window.addEventListener('resize', onWindowResize, false);
            
            // 監聽顏色變化
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                particles.material.color.set(e.target.value);
            });
        }

        // --- 形狀生成邏輯 ---
        function generateShape(type) {
            currentShape = type;
            const tempVector = new THREE.Vector3();

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;

                if (type === 'sphere') {
                    // 球體座標
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    const r = 10;
                    
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);

                } else if (type === 'heart') {
                    // 愛心方程式
                    // 縮放以適配畫面
                    const t = (i / particleCount) * Math.PI * 2;
                    // 分佈修正，使用隨機點填滿體積或沿著線條
                    // 這裡使用隨機體積填充更漂亮
                    const r = 10; 
                    
                    // 使用棄選法生成內部點，或者簡單的參數方程表面
                    // 為了即時性，使用簡單參數方程並加入一些隨機抖動
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    // 基本心形公式
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    // 這裡做一個 3D 旋轉變體
                    
                    // 隨機分佈
                    let u = Math.random() * Math.PI * 2;
                    let v = Math.random() * Math.PI;
                    
                    // 為了讓形狀更像實體，我們混合一些隨機性
                    let scale = 0.5;
                    let bx = 16 * Math.pow(Math.sin(u), 3);
                    let by = 13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u);
                    
                    // 擴展到 Z 軸
                    let bz = 4 * Math.cos(u) * Math.sin(v) * 4; // 隨意厚度

                    x = bx * scale;
                    y = by * scale;
                    z = bz * (Math.random() - 0.5) * 2; // Z軸厚度隨機
                    
                } else if (type === 'saturn') {
                    // 土星 = 球體 + 環
                    if (i < particleCount * 0.4) {
                        // 本體
                        const phi = Math.acos(-1 + (2 * i) / (particleCount * 0.4));
                        const theta = Math.sqrt((particleCount * 0.4) * Math.PI) * phi;
                        const r = 6;
                        x = r * Math.cos(theta) * Math.sin(phi);
                        y = r * Math.sin(theta) * Math.sin(phi);
                        z = r * Math.cos(phi);
                    } else {
                        // 環
                        const angle = (i / (particleCount * 0.6)) * Math.PI * 20; // 繞多圈
                        const r = 10 + Math.random() * 6; // 半徑 10~16
                        x = r * Math.cos(angle);
                        z = r * Math.sin(angle);
                        y = (Math.random() - 0.5) * 0.5; // 非常扁平
                        
                        // 旋轉環以增加立體感
                        let tempX = x;
                        let tempY = y * Math.cos(0.4) - z * Math.sin(0.4);
                        let tempZ = y * Math.sin(0.4) + z * Math.cos(0.4);
                        x = tempX; y = tempY; z = tempZ;
                    }

                } else if (type === 'dna') {
                    // 雙螺旋
                    const turns = 5;
                    const angle = (i / particleCount) * Math.PI * 2 * turns;
                    const radius = 5;
                    const height = 20;
                    
                    // 決定是哪一條鏈 (偶數/奇數)
                    const offset = (i % 2 === 0) ? 0 : Math.PI;
                    
                    x = radius * Math.cos(angle + offset);
                    z = radius * Math.sin(angle + offset);
                    y = (i / particleCount) * height - height / 2;
                    
                    // 加入一些隨機雜訊讓它看起來像粒子雲
                    x += (Math.random() - 0.5) * 1.5;
                    z += (Math.random() - 0.5) * 1.5;

                } else if (type === 'cube') {
                    // 立方體
                    const size = 16;
                    x = (Math.random() - 0.5) * size;
                    y = (Math.random() - 0.5) * size;
                    z = (Math.random() - 0.5) * size;
                    
                } else if (type === 'random') {
                    // 隨機擴散 (大爆炸)
                    const r = 30 * Math.random(); // 廣泛分佈
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                // 儲存目標位置
                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
        }

        // 切換形狀 UI 響應
        function changeShape(type) {
            // 更新 UI 按鈕狀態
            document.querySelectorAll('.shape-grid button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${type}`).classList.add('active');
            
            // 生成新形狀數據
            generateShape(type);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 動畫迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsAttribute = geometry.attributes.position;
            const positionsArray = positionsAttribute.array;

            // 1. 粒子變形 (Morphing) 邏輯
            // 將目前粒子位置 慢慢移動到 目標位置
            const morphSpeed = 0.05; // 變形速度 (0.01~0.1)

            for (let i = 0; i < particleCount; i++) {
                const px = positionsArray[i * 3];
                const py = positionsArray[i * 3 + 1];
                const pz = positionsArray[i * 3 + 2];

                const tx = targetPositions[i * 3];
                const ty = targetPositions[i * 3 + 1];
                const tz = targetPositions[i * 3 + 2];

                // 簡單的線性插值 (Lerp)
                positionsArray[i * 3]     += (tx - px) * morphSpeed;
                positionsArray[i * 3 + 1] += (ty - py) * morphSpeed;
                positionsArray[i * 3 + 2] += (tz - pz) * morphSpeed;
            }
            
            positionsAttribute.needsUpdate = true;

            // 2. 整體旋轉
            particles.rotation.y += 0.002;
            particles.rotation.x += 0.001;

            // 3. 手勢互動縮放
            // 使用 Lerp 讓縮放變平滑，避免手部抖動造成閃爍
            handInteractionScale += (targetScale - handInteractionScale) * 0.1;
            particles.scale.set(handInteractionScale, handInteractionScale, handInteractionScale);

            renderer.render(scene, camera);
        }

        // --- MediaPipe Hands 設定 ---
        
        function onResults(results) {
            // 隱藏載入畫面
            const loader = document.getElementById('loader');
            if(loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => { loader.style.display = 'none'; }, 500);
            }

            const handStatus = document.getElementById('hand-status');
            const handDot = document.getElementById('hand-dot');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // 偵測到手
                handStatus.innerText = "已偵測到手部";
                handStatus.style.color = "#fff";
                handDot.classList.add('active');

                // 取第一隻手
                const landmarks = results.multiHandLandmarks[0];

                // 簡單演算法判斷 "張開" vs "握拳"
                // 計算 掌心(0) 到 指尖(8, 12, 16, 20) 的平均距離
                // 0: WRIST
                // 8: INDEX_FINGER_TIP
                // 12: MIDDLE_FINGER_TIP
                // 16: RING_FINGER_TIP
                // 20: PINKY_TIP

                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let totalDist = 0;

                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    // 計算歐幾里得距離 (僅用 x, y，忽略 z 簡化計算)
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    totalDist += d;
                });

                const avgDist = totalDist / tips.length;

                // 設定閾值 (根據經驗值微調)
                // 張開通常 avgDist > 0.3 ~ 0.4
                // 握拳通常 avgDist < 0.15 ~ 0.2
                
                // 將距離映射到縮放比例
                // 當 avgDist 小 (握拳) -> targetScale 小 (0.5)
                // 當 avgDist 大 (張開) -> targetScale 大 (2.0)
                
                // 限制範圍並映射
                const minVal = 0.15; // 握拳極限
                const maxVal = 0.45; // 張開極限
                
                let normalized = (avgDist - minVal) / (maxVal - minVal);
                // Clamp 0 to 1
                normalized = Math.max(0, Math.min(1, normalized));

                // 映射到 0.3 ~ 2.5 倍縮放
                targetScale = 0.3 + (normalized * 2.2);
                
                // 更新狀態文字 (除錯用)
                if (normalized > 0.7) handStatus.innerText = "狀態：張開 (擴張)";
                else if (normalized < 0.3) handStatus.innerText = "狀態：握拳 (收縮)";
                else handStatus.innerText = "狀態：變換中...";

            } else {
                // 沒偵測到手
                handStatus.innerText = "未偵測到手部";
                handStatus.style.color = "#aaa";
                handDot.classList.remove('active');
                
                // 回復預設大小
                targetScale = 1.0;
            }
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    console.log("Camera started");
                })
                .catch(err => {
                    console.error("Error starting camera:", err);
                    alert("無法啟動攝影機，請確認權限設定。");
                    document.getElementById('loader').innerHTML = "<div>攝影機啟動失敗<br>請確認瀏覽器權限</div>";
                });
        }

        // --- 啟動程式 ---
        initThree();
        animate();
        
        // 延遲一點初始化 MediaPipe 以確保頁面載入完成
        window.onload = () => {
            initMediaPipe();
        };

    </script>
</body>
</html>