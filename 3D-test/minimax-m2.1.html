<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100vh; }
        #ui {
            position: absolute; top: 20px; right: 20px;
            background: rgba(20, 20, 20, 0.8); padding: 20px;
            border-radius: 10px; color: white; z-index: 100;
            backdrop-filter: blur(5px); border: 1px solid #444;
            user-select: none;
        }
        select, input { margin-bottom: 10px; width: 100%; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        label { font-size: 12px; color: #aaa; display: block; margin-bottom: 4px; }
        #status { margin-top: 10px; font-size: 11px; color: #f44; text-align: center; white-space: nowrap; line-height: 1.5; }
        .hint { font-size: 10px; color: #666; margin-top: 5px; }
    </style>
</head>
<body>

<div id="ui">
    <label>Shape</label>
    <select id="shape">
        <option value="heart">Heart</option>
        <option value="flower">Flower</option>
        <option value="saturn">Saturn</option>
        <option value="firework">Firework</option>
        <option value="sphere">Sphere</option>
    </select>

    <label>Color</label>
    <input type="color" id="color" value="#ff0055">

    <div id="status">Initializing...</div>
    <div class="hint">Tip: Run on localhost or HTTPS for camera access.</div>
</div>

<video id="input_video" style="display:none" playsinline></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 4000;
    
    // --- Three.js Setup ---
    const scene = new THREE.Scene();
    // Use distinct name to avoid conflict with MediaPipe camera
    const threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    threeCamera.position.z = 4;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- State ---
    let currentShape = 'heart';
    let particleColor = 0xff0055;
    let targetScale = 1.0;
    let currentScale = 1.0;
    let handOpenness = 0.5;
    const uiStatus = document.getElementById('status');
    const uiShape = document.getElementById('shape');
    const uiColor = document.getElementById('color');

    // --- UI Events ---
    uiShape.addEventListener('change', (e) => { currentShape = e.target.value; updateShape(); });
    uiColor.addEventListener('input', (e) => {
        particleColor = new THREE.Color(e.target.value);
        material.color = particleColor;
    });

    // --- Particle System ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const randoms = new Float32Array(PARTICLE_COUNT);
    for(let i=0; i<PARTICLE_COUNT; i++) randoms[i] = Math.random();

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: particleColor,
        size: 0.03,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    let basePositions = new Float32Array(PARTICLE_COUNT * 3);

    // --- Shape Generator ---
    function updateShape() {
        const pos = geometry.attributes.position.array;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = randoms[i];
            let x, y, z;

            switch (currentShape) {
                case 'heart':
                    const t = r * Math.PI * 2;
                    x = 1.5 * 16 * Math.pow(Math.sin(t), 3);
                    y = 1.5 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (r - 0.5) * 0.5;
                    break;
                case 'flower':
                    const theta = r * Math.PI * 2;
                    const phi = Math.PI * Math.random();
                    const k = 0.5; 
                    const r_rose = 1.5 + k * Math.cos(5 * theta);
                    x = r_rose * Math.sin(phi) * Math.cos(theta);
                    y = r_rose * Math.sin(phi) * Math.sin(theta);
                    z = k * Math.cos(phi);
                    break;
                case 'saturn':
                    if (Math.random() > 0.3) {
                        const ang = r * Math.PI * 2;
                        const rad = 1.5 + Math.random() * 0.3;
                        x = Math.cos(ang) * rad;
                        y = (Math.random() - 0.5) * 0.1;
                        z = Math.sin(ang) * rad;
                    } else {
                        const phi_s = Math.acos(2 * Math.random() - 1);
                        const theta_s = Math.sqrt(Math.random()) * Math.PI;
                        const rad_s = 0.5 + Math.random() * 0.2;
                        x = rad_s * Math.sin(phi_s) * Math.cos(theta_s);
                        y = rad_s * Math.sin(phi_s) * Math.sin(theta_s);
                        z = rad_s * Math.cos(phi_s);
                    }
                    break;
                case 'firework':
                    const theta_f = Math.random() * Math.PI * 2;
                    const phi_f = Math.acos(2 * Math.random() - 1);
                    const dist = r * 2.5;
                    x = dist * Math.sin(phi_f) * Math.cos(theta_f);
                    y = dist * Math.sin(phi_f) * Math.sin(theta_f);
                    z = dist * Math.cos(phi_f);
                    break;
                default: 
                    const phi_sp = Math.acos(2 * Math.random() - 1);
                    const theta_sp = Math.sqrt(Math.random()) * Math.PI * 2;
                    const rad_sp = 2.0;
                    x = rad_sp * Math.sin(phi_sp) * Math.cos(theta_sp);
                    y = rad_sp * Math.sin(phi_sp) * Math.sin(theta_sp);
                    z = rad_sp * Math.cos(phi_sp);
                    break;
            }
            
            x += (Math.random()-0.5) * 0.05;
            y += (Math.random()-0.5) * 0.05;
            z += (Math.random()-0.5) * 0.05;

            basePositions[i*3] = x;
            basePositions[i*3+1] = y;
            basePositions[i*3+2] = z;
            
            pos[i*3] = x;
            pos[i*3+1] = y;
            pos[i*3+2] = z;
        }
        
        geometry.attributes.position.needsUpdate = true;
    }

    updateShape();

    // --- MediaPipe Hands ---
    // Check if Hands is loaded
    if (typeof Hands !== 'undefined') {
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const index = landmarks[8];
                const pinky = landmarks[20];
                
                const dx = index.x - pinky.x;
                const dy = index.y - pinky.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // 0.05 (closed) -> 0.2 (open)
                let openness = (dist - 0.05) / 0.15;
                openness = Math.max(0, Math.min(1, openness));
                
                handOpenness = handOpenness * 0.8 + openness * 0.2;
                
                targetScale = 0.3 + handOpenness * 2.2;
                
                uiStatus.innerText = `Status: ${handOpenness > 0.5 ? 'OPEN (Expand)' : 'CLOSED (Contract)'}`;
                uiStatus.style.color = "#4f4";
            } else {
                targetScale = 1.0;
                uiStatus.innerText = "Status: No hand detected";
                uiStatus.style.color = "#f44";
            }
        }

        // --- MediaPipe Camera ---
        const videoElement = document.getElementById('input_video');
        
        // Use 'mpCamera' to avoid conflict with Three.js camera
        const mpCamera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        mpCamera.start()
            .then(() => {
                uiStatus.innerText = "Camera Active. Show hand!";
                uiStatus.style.color = "#4f4";
            })
            .catch(e => {
                console.error(e);
                uiStatus.innerText = "Camera Error: " + e.message;
                uiStatus.style.color = "#f44";
            });
    } else {
        uiStatus.innerText = "Error: MediaPipe libraries failed to load.";
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);

        currentScale += (targetScale - currentScale) * 0.1;
        
        const pos = geometry.attributes.position.array;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            pos[i3] = basePositions[i3] * currentScale;
            pos[i3+1] = basePositions[i3+1] * currentScale;
            pos[i3+2] = basePositions[i3+2] * currentScale;
        }
        geometry.attributes.position.needsUpdate = true;

        particles.rotation.y += 0.005;
        particles.rotation.z += 0.002;

        renderer.render(scene, threeCamera);
    }
    
    animate();

    window.addEventListener('resize', () => {
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
